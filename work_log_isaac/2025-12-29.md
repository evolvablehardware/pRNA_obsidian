## Log
- I was looking into removing a bunch of the errors in the sphinx website so I can start to move the mostly refactored code onto the website to help ease back in, and solve a problem that requires a bit of time more that anything.
- I solved a couple of problems, like officially declaring a 404.rst page an `:orphan:` to avoid having a warning in the output. 
- It would be good to have the docs deploying properly without warning to be a part of the deployment pipeline, so removing these warnings is needed.
- The next biggest error that I found was that the [result module](https://pypi.org/project/result/) that I had used didn't have any sphinx documentation page, making it harder to link to. Then, I looked into it in more detail and noticed that they don't seem to be maintaining it [on their github page](https://github.com/rustedpy/result). This isn't bad, but it is a little unsettling, so I briefly looked around for other alternatives.
	- It suggested two different possible replacements that do seem to be being maintained.
- [Poltergeist](https://github.com/alexandermalyga/poltergeist) - Rust-like error handling in Python, with type-safety in mind. (No Docs)
	- This seems like a pretty good option if we just want to get rust-like Errors with a 'Result' enum-like object, but no Optional object.
	- The name is also not all that intuitive, which doesn't help it.
	- There is also not a ton of documentation, especially with sphinx, but the documentation does seem plenty sufficient for anyone who kind of knows what they are doing.
	- This would be a pretty drop-in replacement, with potentially a little better syntax.
	- This seems to be being consistently maintained, although it doesn't seem to be changing much, so that doesn't seem to be much work.
- [Returns](https://github.com/dry-python/returns) - Make your functions return something meaningful, typed, and safe! (Sphinx Docs [here](https://returns.rtfd.io/).)
	- This seems to offer the rust error handling and more, but not using the Rust names, but these names are similarly structured and intuitive, potentially even more pythonic.
	- There is a bunch of stuff to annotate impure functions (`IO` & `IOResult`) which I don't really care about, but I guess is nice.
	- It does have `Future` functionality to allow you to deal with async code in synchronous functions far more pleasantly, plus it integrates well with it's own Result object.
	- It has a `Result` object that uses Success and Failure instead of Ok and Err, which is less rustic, but more intuitive and pythonic. It also allows you to use pipes for very convenient function composition.
	- It also has a `Maybe` object to represent these objects that replaces `Optional[n]` Far more conveniently, like with rust.
	- It also allows you to make your own container, which may be nice... I don't know.
	- This seems to have a lot of the functional functionality that I liked from the original result module, and also seems to have a reasonable answer to dealing with async in synchronous code conveniently, which was something that I was kind of looking at. 
	- Overall, I think that this has enough advantages and is a little more readable than the original `Result` module that it would be worth switching to it.
- Doing a bunch of random research, mostly talking with chat GPT, I determined that using async and adjusting pools would likely be the best approach for performing a bunch of the evaluations because we can switch between threads and multiprocessing by changing the pool we use (i.e. `ThreadPoolExecutor` or `ProcessPoolExecutor`) depending on if we are sending a lot of data out to a network and waiting for replies or if we are very CPU-bound.
- I am planning to switch to using `Returns`, especially because it has good Docs that explain and justify what it is, as well as sphinx so intersphinx can link to it well.
- I started trying to fix the warning from Nefertiti, which required updating a bunch of stuff in poetry, which required a lot of updating and me trying to figure out how to handle poetry better, now that I have a little experience with it.
- I added a branding repo to store all of the logos for the various repositories to keep that together and be able to turn that into a submodule eventually.
## Next
- Update code to use the `Returns` Module

[[work_log_isaac/2025-12-26|prev]] [[work_log_isaac/2025-12-30|next]]
