## Log
- Thoughts on transfer experiments
	- It is quite clear that these chips also contain undefined behavior - [[transfer_log]]
	 - I think the undefined behavior certainly has its place, but I think it is best suited for self evolution type of systems that only care about the behavior of its specific chip.
	 - I think the most obtainable end goal is to provide circuit approximations for specialized compute units that care more about speed than accuracy
	 - I think undefined behavior starts to become a problem when some of the devices evaluate circuits to be under the target pulses, while some are evaluated to be over. This means that different circuits now have opposite goals for new mutations. The best case scenario would be that the circuit converges to one that is more consistent, otherwise we will end up with some that perform well while others move further away from the target pulses, unless more undefined behavior is used
	 - I think that circuit fitness should be penalized based on how large the spread between evaluations on different devices are to reduce undefined behavior - that's not to say that we should not allow any
	 - I think we should start experiments on a few devices (3-5?) to ensure that not everything is based on undefined behavior, then scale to all available devices to fine tune it out. We would probably get better results with the same number of generations if we evaluated on all devices, but I suspect that the evaluation speed trade off of only using a few devices for most of the experiment might be worth it.
	- I'm not entirely sure how the current fitness function works. I've been using the tolerant one, but I increased the deviation to 0.5 from 0.025. Previously circuits with really high or low pulse counts were being rounded to 0 fitness from double precision, which made operations on individual device evaluations across multiple evaluations really annoying, as one 0 could easily 0 out the entire fitness value.
	- I tried using min() yesterday with 40khz target. It worked well until each evaluation was about 5k pulses off where it stalled for a while and I stopped the experiment. Some devices evaluated 45khz while others evaluated 35khz, which I theorized to be the issue
	- Currently trying mul()
- Investigating iCEFARM issue
	- Crash on client
	- min() iterable argument is empty File "/home/heiljj/ehw/iCEFARM/src/icefarm/client/lib/BatchRequest.py", line 47, in __next__ slots = min(self.batch_size - serial_amounts[serial] for serial in serials) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File "/home/heiljj/ehw/iCEFARM/src/icefarm/client/lib/BatchRequest.py", line 116, in getBatches 
	- I'm not able to inspect the client since the bitstreamevolution thread is sleeping. It appears that at some point client.getSerials returned no serials.
	- Reservation is still active
	- control-1  | [Control] [ControlEventSender] [EventSender] [bitstream evolution] flushed 2 events
		control-1  | [Control] [Heartbeat] Sent ending soon notification for 1B66CE91AB184A50
		control-1  | [Control] [Heartbeat] heartbeat success for host_worker
		worker-1   | [EventSender] [bitstream evolution] socket disconnected
		control-1  | INFO:     127.0.0.1:50486 - "GET /extend HTTP/1.1" 200 OK
		worker-1   | INFO:     127.0.0.1:33712 - "GET /heartbeat HTTP/1.1" 200 OK
		control-1  | [Control] [Heartbeat] heartbeat success for host_worker
		control-1  | [host_worker@1] [EventSender] [bitstream evolution] socket disconnected
		control-1  | INFO:     127.0.0.1:59876 - "GET /log HTTP/1.1" 200 OK
		worker-1   | INFO:     127.0.0.1:55536 - "GET /heartbeat HTTP/1.1" 200 OK
		control-1  | [Control] [Heartbeat] heartbeat success for host_worker
		control-1  | [Control] client bitstream evolution disconnected
		control-1  | [Control] [ControlEventSender] [EventSender] [bitstream evolution] socket disconnected
		worker-1   | INFO:     127.0.0.1:52916 - "GET /heartbeat HTTP/1.1" 200 OK
		control-1  | [Control] [Heartbeat] heartbeat success for host_worker
		worker-1   | INFO:     127.0.0.1:41952 - "GET /heartbeat HTTP/1.1" 200 OK
		control-1  | [Control] [Heartbeat] heartbeat success for host_worker
		worker-1   | [EventSender] [bitstream evolution] client did not connect in time
		worker-1   | INFO:     127.0.0.1:47424 - "GET /heartbeat HTTP/1.1" 200 OK
		control-1  | [Control] [Heartbeat] heartbeat success for host_worker
		control-1  | [host_worker@1] [EventSender] [bitstream evolution] client did not connect in time
		control-1  | INFO:     127.0.0.1:36734 - "GET /log HTTP/1.1" 200 OK
		worker-1   | INFO:     127.0.0.1:48248 - "GET /heartbeat HTTP/1.1" 200 OK
		control-1  | [Control] [Heartbeat] heartbeat success for host_worker
		control-1  | [Control] [ControlEventSender] [EventSender] [bitstream evolution] client did not connect in time
	- Client socket disconnected and did not reconnect, further supporting the no serials thing. My guess is that the ending soon notification went wrong somehow, causing the client to think the device was no longer reserved. Either way, need to some checks to the evaluation class; this should not have propagated this far
	- The only thing different about this experiment is that there is only one device. I have not run into a reservation issue since the original fix
	- Client logs show socket disconnect but does not mention anything about the reservation extension
		- eventserver doesn't log this by default, changed this
	- Seems to be either:
		- Reservation end notification mistakenly sent/interpreted
		- Device failure sent/interpreted
			 - Doesn't seem possible to have been an actual device failure
		- It's possible that the disconnect was just interference and caused serial to be removed, but I don't see how how this could in practice
		- I'm not really sure at this point, I'm going to run again with the additional logging and hope it happens again. 
	- I have a feeling having a single device connected had something to do with it. This is the first reservation extension with only one device connected. At the same time though I don't see how the eventserver would effect anything
- Ran experiment with one device targeting 40khz 
- More thoughts about transfer experiments
	- I might try just zeroing fitness if pulses differ too much. I think that when targeting 40khz, a (13k, 13k, 13k) result is going to be better than a (30k, 13k, 13k) one?
	- Currently trying to scale fitness by inverse variance, working well until previous bullet result occurred. That being said, each epoch up until 8 so far has had a new best fitness, so I am pretty impressed with it so far.
	```
if not max(data) or all(data[0] == point for point in data):

	multiplier = 1

else:

	u = sum(data) / len(data)
	
	s2 = sum((point - u) ** 2 for point in data) / len(data)
	
	multiplier = 1 / (s2 / max(data))

return reduce(mul, (Decimal(self.__calculate_pulse_fitness(float(point))) for point in data), 1) * multiplier
	```
Using 0.05 for deviation value instead of 0.025
- This worked really well until about 37k pulses, where staying consistent between circuits seemed to become more important than improving
- Planning on trying inverse MSE next, with the intent of eventually adding some additional penalty if circuits differ in being above/below target
## Next
- [ ]

[[work_log_jackson/2026-01-20|prev]] [[work_log_jackson/2026-01-22|next]]