## Log
- I looked into using pyudev in kernel mode. I am confident that I can use this to detect disconnects even when exporting through usbip. At some point I will implement this for the purpose of a proof of concept in the current iteration of the usbip manager, but for the most part I think this version works pretty well (currently syncing disconnected devices on api requests instead, more resource intensive). The next step is going to be to move to an architecture that allows for multiple devices running the manager to be easily queried. The ability to produce disconnect events despite using usbip will make this a lot easier. 
- Design considerations 
	- The simplest design possible is a database and worker nodes connected to the physical devices. The worker nodes listen for device events and update entries in the database on where each device is being updated.
	- Add a separate server so clients don't have to directly query the database
	- We need some sort of heartbeat system for the worker nodes. If a node completely fails and has outgoing connections, we need to know to remove them from the database.
		- Add a server on the worker nodes for heartbeating
		- We need some device to actually check on the nodes. Theoretically, this is [*possible*](https://blog.dotnetframework.org/2019/09/17/make-a-http-request-from-sqlserver-using-a-clr-udf/) to do entirely on the database? This sounds kinda awful though and we should probably just do this on the same device as the client api. 
		- Since were running a server on the worker nodes now, it makes it convenient to include the firmware flashing functionality as an endpoint as well. 
			- An alternative solution is to use usbip to upload things and include it as an endpoint in the client api. This creates a nice abstraction layer, but it would be slower since we would have to poll for when the bootloader becomes available by usbip (going into bootloader mode causes the device to disconnect, which in turn unbinds the bus from usbip, it doesn't rebind until the bootloader is exposed)
	- At some point someone is going to upload firmware that breaks the baud bootloader protocol and cannot be reflashed automatically.
		- When a device is no longer being reserved, we flash a default firmware to it. It if fails we can set the device aside, otherwise we know that it is ready to have new firmware uploaded to it again.
	- Handling devices stuck in reserved mode
		- Program reserves device, crashes, oops the device is reserved for the rest of time. We just need to change how reservations are made so that it is on a time limit and the client needs to refresh the reservation every so often.
## Next
- [ ]

[[work_log_jackson/2025-10-13|prev]] [[work_log_jackson/2025-10-15|next]]
