## Log
- Going back to mpremote, I realized it took a few seconds to copy the bitstream over to the remote. I don't think its really worth pursuing further with this in consideration. It does worry me a bit though, since I would think that this would have been implemented in C.
- I think an important goal is to try to get a remote bootloader working. I think the usbip stuff won't be nearly as useful without it. 
	- It's supposed to be possible using [picocom](https://pico2-ice.tinyvision.ai/md_programming__the__mcu.html), but I have not been able to get it working. Instead, I enter the micropython repl. I'm going to try to upload something that is not micropython and see if that fixes it. 
	- I uploaded the ice_makefile_blinky and was not able to use picocom 
	- I then uploaded the rpi2_usb_uart and it worked
		- My working theory is that this functionality is provided by tusb
		- I removed the tud_task() event loop and can't use picocom any more, this seems to be the case
	- **We should be able to remotely update the rpi firmware, provided that the one running actually listens on the usb port**.
		- I think the main limitation this introduces is not really needing to listen to the usb, since that is pretty necessary anyways, but if an bug causes the firmware to stop listening it needs to be manually reflashed
		- We also cant flash out of the box using this method since micropython is used, but if this this becomes an actual bottleneck we could check if the device is running mpy and use that to start the bootloader instead
		- I think this is fine for the most part, the only big issue I see is the potential nightmare situation when bad firmware is uploaded to a large amount of fpgas that have to be manually reflashed
- Meeting with Ben 
	- For fitness functions that care about multiple circuits, we can create a worker node that evaluates them all. If we go this route, it will be a much different architecture, as the computer connected to the pico won't be the worker. 
- Try to upload rpi firmware through usbip
	- I was able to start the bootloader though usbip. However, once the bootloader is started, the pico mounts as a different device. I suspect it will be necessary to make a wrapper around usbip in order to facilitate uploading firmware.
	- Was able to upload new firmware!
		- When the bootloader is started, it mounts as a new device. I had to expose the new device with usbip (/dev/sbd1), mount it, then upload the firmware. 
	- I think that it might be best to use usbip to connect during experiments and host a server endpoint for uploading firmware. The fact that the pico reconnects as a different device makes things much more complicated, and using usbip only adds to that. I don't see any situation where someone wants to put the device into firmware flashing mode but not do any of the firmware flashing part. 
	- My greatest concern at the moment is dealing with multiple picos connected to a single host computer. I'm not really sure how to keep track which is which, especially if they have different firmware.
		- We could of course just not have this functionality. However, this is far from ideal as we don't need much compute power on the host computer, so needing a separate one for each fpga is a significant cost multiplier 
		- We could first put all the devices connected devices into bootloader mode, than upload the firmware. This ensures that we do not miss an fpga while updating firmware from unexpected device changes. This introduces the limitation that each cluster runs the same firmware. This might not actually be terrible if your running on a larger scale and the individual fpga doesn't matter. For the EHW use case, this would mean we could only identify fpgas as a member of a cluster rather than an individual.
		- Aside from the limitations it would introduce, we cannot identify devices based on their firmware, since it does not run in bootloader mode 
		- The best solution would probably involve identifying devices based on the port they are plugged into. My main concern with this approach is we will need to confirm that the usb hubs we use correctly report this information.
			- This is my next goal to work towards. I'm imagining a system that routinely scans for connected dev files and adding them to a lookup table based on their port. 
			- We should be able to use the ID_SERIAL parameter from udevadm. I still need to do some testing to confirm that it is persistent across firmware changes, but it works across both normal and bootloader mode.  
- Ensuring ID_SERIAL works how I think it does
	- pico1 test 1
		- normal: Raspberry_Pi_Pico_BB26BACCA68C3D58
		- bootloader:      RPI_RP2350_BB26BACCA68C3D58-0:0
	- pico1 test 2
		- normal: Raspberry_Pi_Pico_BB26BACCA68C3D58
		- bootloader:      RPI_RP2350_BB26BACCA68C3D58-0:0
	- pico2 test 1
		- normal: Raspberry_Pi_Pico_0B2136D98D7DA257
		- bootloader:      RPI_RP2350_0B2136D98D7DA257-0:0
	- pico2 test 2
		- normal: Raspberry_Pi_Pico_0B2136D98D7DA257
		- bootloader:      RPI_RP2350_0B2136D98D7DA257-0:0
	- Looks good! We should be able to easily identify what fpga is what since the same serial is used in both the normal and bootloader mode. 
- Plan for usbip interface
	- First, write a manager for interfacing with the devices. This manager will look for relevant dev files (or use system events? probably not worth the effort? I think its probably fine to use a separate thread) and add them to an registry. 
		- An endpoint for updating firmware. This will use server-sent events.
		- An endpoint for using usbip. This will return a remote location and busid for use with usbip, along with exposing the dev to usbip. 
			- We also want to send some sort of identifying device information to make it easier to find the newly connected device, as usbip doesn't really provide much to help with this
		- An endpoint for signaling that the host is done using a device, which will unbind the device from usbip and allow it to be used again.
			- Ideally this could be done automatically when a device disconnects from usbip. 
		- Some stuff for analytics, such as getting current device serials and their firmware
		- Since were dealing with managing dev files, going to need to have higher privileges 
			- Since we really just need to use usbip and udevadm, we can create a group for the manager 
	- Next, a centralized system for working with multiple managers, with the purpose of being able to find any device. I think this could be as simple as a database that the managers fill with entries of \[ip, device, firmware\].
		- A database would be really simple to set up, but I think this might limit our future functionality. For example, at some point we are going to want to be able to reserve fpgas. 
	- A util for interfacing with the system.
		- Get available fpgas, reserve fpgas
		- Connect to fpga (send connection request, connect with usbip, find and return dev file)
		- Disconnect from fpga

## Next
- []

[[work_log_jackson/2025-09-22|prev]] [[work_log_jackson/2025-09-24|next]]
