## Log
- While working to test the client cli, I encountered a strange usbip state. The bus was bound to usbip, but not listed under the available devices. From dmesg:
	- [137056.209200] usbip-host 1-1.2: usbip-host: register new device (bus 1 dev 111)
		[137576.519556] usbip-host 1-1.2: stub up
		[137576.924357] usbip-host 1-1.2: endpoint 0 is stalled
		[137576.931358] usbip-host 1-1.2: endpoint 0 is stalled
		[137576.939477] usbip-host 1-1.2: endpoint 0 is stalled
	- It seems that the device was bound, but some error prevented it from being available. I unbound the device, and the device manager correctly reexported it. I'm not sure what the issue was caused by. If it happens again I'll do some digging into where the error message originates from. 
- Initial client connection works
- Setup globalprotect on rpi, confirmed I'm able to setup a demo from here
- Added unbind event notifications from control
- I encountered the usbip issue again.
	- The dev files are not available to the user - ttyACM or an sd did not exist. This seems to indicate that the device is being bound correctly, but is not available for some reason. 
	- The device is not available under usbip list. It's important to note that I'm using the -r flag - this connects to a usbip client and gets available devices. I have not been able to find an intended way to get devices bound besides this - I don't believe one exists in the cli. 
	- I noticed this after I came back to my device after a period of idling. The RPI was still running, but the device manager was not. The other connected device was being properly exported over usbip.
	- When the device manager is turned off, it unbinds devices from usbip. However, this uses the python atexit module and can be easily interrupted with an additional ctrl c. Since the other device was still connected to usbip, I believe that I interrupted the exit process while the device with the strange state was being unbound, which caused an issue. 
	- If this is the case, it's really no big deal. However, it could be a problem if this is being caused by something else.
	
- Figure out usbip issue
	- Locate error message origin in kernel module
		- https://github.com/torvalds/linux/blob/24172e0d79900908cf5ebf366600616d29c9b417/drivers/usb/usbip/stub_tx.c#L61
	- Try do reproduce by interrupting bind command 
	- If the cause is something else, we need to find a more reliable way to list devices that are being exported. I suspect that this can be done by comparing the connected kernel and user space device files, as those being exported over usbip will not appear to the user. However, this would be pretty slow. 
	
	- Steps to reproduce
		- Bind device on host
		- Attach to device on client
		- Reboot client
		
	- Once the client attaches the device, it is no longer available under the list because it is being used (can't have more than one connection).
	- The client is unable to reconnect to the device
	
- I suspect that we will have the same behavior if we experience a internet issue. Some ways to go about it:
	- When a reservation ends, we can try to unbind the device even if it is not being shown as exported by usbip. Once the device is unbound, it works exactly as we want. Essentially, if a disconnect happens when a device is still being connected to, the device is still inaccessible for the remainder of the session, but will go back to a valid state after it is over. 
		- This is the option I plan on implementing
	- I don't think we can use kernel events like we did to detect when a device failure happens. The device is still bound to usbip, but there is just nothing listening to it.
	- We could in theory make an endpoint to temporarily unbind the device that the client can use if this issue occurs. At the moment, I don't think this is worth doing? At least for the reboot option, it doesn't really matter if the device is no longer accessible to the client, the state is already pretty unrecoverable. I do wonder about the internet disconnects though - if this becomes a big problem this could be used, but still kinda messy as it requires the client to perform these actions. 
	- We could add client heartbeating in addition to the end of reservation checks. This would work pretty well if we wanted the option to reconnect to devices, it adds some significant architectural complexity though.
		- This would not be the worst since the client already has to run a server to listen for device event updates
		- That being said, I am kind of working on a plan to remove this?
		- I've wanted to switch to server sent events instead of this. However, I am kind of hesitant to. I'm worried that the long connections needed for experiments might have stability issues.  
		
-  I had the realization that since my ice40 upload firmware was failing on some occasions, this means that I should probably revisit running experiments with the better firmware.
	- I'm not actually sure this is the case anymore - my seed circuit had a connection from SW2 to one of the leds, and I occasionally checked that this connection was working 
## Next  
- Finish testing client
- Implement client disconnection checks


[[work_log_jackson/2025-11-10|prev]] [[work_log_jackson/2025-11-12|next]]
