## Log
- Got sidetracked for a while on a different project, some thoughts I had: 
	-  While the behavior with the one circuit is certainly interesting, I don't think the reason behind it is something that's a priority. I found a circuit that breaks all devices, which indicates that there are probably two separate problems (?). I think the best plan of action is to detect fpga crashes and be able to recover from them. 
	- I think the circuit that crashes may be caused by what Thomas described: routing logic tables into themselves. I think that there is something different with the fpga that fails on the one circuit. When I used the embedded bitstream firmware, the two picos seemed to behave differently, but I need to go back and verify this observation.
	- I glanced over the bitstream upload functions in the pico sdk. At some point in the upload, it seemed to wait for a response from the fpga. I presume that after the bitstream upload fails, this stalls, which prevents further communication from the pico. If this hypothesis is correct, I will add a timeout behavior to it.
	- I'm not sure how much logging behavior I will have access to. My hope is that by adding tud_task in internal functions I will be able to get debug information. I also may mess around with micropython to see if the bitstream upload behaves differently, but it is probably built on the same c api.
- I tried using the embedded firmware again on the circuit that seemed to break all devices (circuit 38). I changed a few things for better logging, but this time it seemed to work. I was not able to replicate the result from the previous log. I tried using the circuit with icefarm, and I had the broken result. I am not sure what to make of this.
- Confirmed circuit38 breaks all devices with icefarm
- Confirmed 0b broken only breaks on 0b with icefarm
	- To clarify, when I say a device breaks, I mean that it sends no more messages and does not respond to the baud 1200 protocol
- 0b broken does not fail when embedded. Starting to doubt I tested that correctly previously. 
- **Behavior is reallly inconsistent**, it seems to actually work about half of the time
- I had a bunch of prints happening. My guess is that the buffer they are stored in had an overflow, which is why crashes were more frequent the longer I left the device (and why I was not able to immediately replicate it - I had removed the print). **After removing the print, I am no longer able to get crashes with circuit38 embedded in the firmware on both devices (ones where button works)**
- **I am also no longer able to break the 0B serial device with the circuit that only breaks that device.**
- **icefarm behavior still remains consistent**. Next step is to try uploading with bitstream_over_usb instead of embedded. 
- It appears my initial hypothesis was actually correct! **I added the gpio pin callback and the device stopped working.**
	- We might be able to simply poll the pin value. Would need to benchmark how badly this effects accuracy.
	- Going to try disabling the callback after the evaluation period
		- Did not work. I'm going to just benchmark the other method. Maybe in the future we can do a small poll sample and only set a callback if there is a safe amount of pulses.
			- Not going to do that, we may produce more pulses later on and this increases evaluation time
- Did a few benchmarks, polling does not work at all (though my pulse generator only produces a pulse for one clk cycle, which probably contributes) - I was getting about 1/10 of the expected pulses. My new plan is to use the PIO state machines to count pulses instead. These run separately, so pulse overwhelming is not possible
- Read through PIO docs again
- Got pio working with cmake
- Plan
	- WAIT instr makes it easy to detect a pulse
	- Pulses can be counted by using the JMP instr, which has the option to always decrement a register before the comparison
	- Instructions can be put into SM[idx]_ADDR registers by the cpu to be executed. This allows the pulse counter to be flushed and reset when needed.
- Started working on pulse count firmware with pio. Was able to upload pio program
	- Next need to read from sm
	- Switch to using pulse count sm and verify

	

[[work_log_jackson/2026-01-14|prev]] [[work_log_jackson/2026-01-16|next]]
