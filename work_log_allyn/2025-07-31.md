## Log
### Building Firmware from within the Repo
Modified our makefile to generate the uf2 file. This way, I don't have to copy the bitstream to the BitstreamEvolutionPico repo and generate the uf2 file there. 

> [!New Makefile Target]-
> ```bash
> .ONESHELL:
> controller: build/controller.bin
> 	@if [ "$(DEVICE)" = "hx1k" ]; then \
> 		iceprog build/controller.bin; \
> 		python3 src_python/shell.py; \
> 	elif [ "$(DEVICE)" = "up5k" ]; then \
> 		# TODO: probably a more elegant way of doing this
> 		cd rp_firmware
> 		mkdir -p build
> 		cd build/
> 		cmake .. 
> 		make
> 		cp rp2_ice_bram_controller.uf2 ../../build/
> 		cd ../../
> 		# TODO: use picotool to put the uf2 file on the pi?
> 		echo "Generated build/rp2_ice_bram_controller.uf2"
> 	fi
> ```

There's a couple of commands needed to set up pico-ice-sdk (only need to be run once when the repo is cloned)
```bash
git submodule update --init
cd lib/pico-ice-sdk && git submodule update --init
cd lib/pico-sdk && git submodule update --init
cd ../../../..

ln -s ../lib/pico-ice-sdk/ rp_firmware/pico-ice-sdk
ln -s ../lib/pico-ice-sdk/lib/pico-sdk/ rp_firmware/pico-sdk
```
### Running the Memory Controller on the Pico2
Worked on getting the memory controller running on the pico2 ice. I had to modify our makefile to accept a new argument so it knows what pcf file to use and which board to pass into the firmware's cmake call. I also had the cmake pass a macro into the C so that the RP pins are set up correctly.
```bash
make BRAM=[implicit/explicit] DEVICE=[hx1k/up5k] PICO=[1/2]
```

I worked with Brooklyn and Dr. Yoder to determine what FPGA and RP pins to use to get everything connected. There's an issue where the FPGA's state machine gets sent into the wrong state whenever I start running pyserial. However, after a few reads the problem resolves itself. So, we might just need to send some dummy reads whenever we first boot the device before we start doing actual operations. 

#### Testbench Results
I ran the same testbench as yesterday on the pico2. I uploaded the new files and graphs to the google drive folder I shared yesterday.

There is no significant difference between the pico1 and the pico2. This makes sense, as the clock speed of the FPGA and baud rate is the same between both devices. 
![[Pasted image 20250731142414.png]]

The pico2 only does an inaccurate operation on the first operation for this testbench. I've seen the number of inaccurate operations range from none to 4.
![[Pasted image 20250731144237.png]]

I confirmed the pico2 runs into the same buffer overflow problems as the pico1.
### SPRAM
Started working the SPRAM implementation. I reviewed [ice40 docs](https://pages.hmc.edu/brake/class/e155/fa23/assets/doc/FPGA-TN-02022-1-3-iCE40-SPRAM-Usage-Guide.pdf) and a [tutorial](https://projectf.io/posts/spram-ice40-fpga/) on SPRAM. I figured since we're no longer modifying the SPI flash from the FPGA, we use the space I reserved for that in the command structure for SPRAM operations instead.

| ==**Byte 1**== |                         |                            |                               |                          |
| -------------- | ----------------------- | -------------------------- | ----------------------------- | ------------------------ |
| **Bit**        | 7                       | 6                          | 5                             | 4:0                      |
| **Data**       | 0 for BRAM, 1 for SPRAM | 0 if reading, 1 if writing | 1 if warmbooting, 0 otherwise | Block to read/write from |
For SPRAM operations, we then send 2 bytes for the address. The rest of the bytes proceed as normal (1 byte for the size of the operation, and then write data if we are writing).

Note: I couldn't find any examples of anyone initializing SPRAM with a datafile, so our data might have to be written to at the start.

I created a new SPRAM module, and modified the top level and controller of the design. I made sure the SPRAM when we're synthesizing for the hx1k device by using yosys preprocessor macros.

I didn't have time to test the implementation, as I still need to write pyserial code to interface with the SPRAM. However, I did confirm, using the output of nextpnr, all SPRAM blocks get instantiated. I also confirmed the design still works fine on the HX1K device.
#### TLDR
- Implemented SPRAM things
- We likely cannot init SPRAM with a data file
- Not tested, still need to write code with pyserial to interface with it
- Confirmed it doesn't break our HX1K implementation
## Next
- BRAM/SPRAM Demo
	- Write pyserial code to interface with SPRAM
	- Test and debug SPRAM implementation
	- Create and run testbench for SPRAM
	- Write README
	- Modify state diagram drawing
	- Figure out how to time read + writes from the Pi

[[2025-07-30|prev]] [[2025-08-01|next]]
