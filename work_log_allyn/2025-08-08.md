## Log
### Warmboot Progress
I was able to successfully figure out how to program the FPGA using the flash.  However, even when I did that, warmbooting still does not seem to work. When I trigger it, the leds turn purple (regardless of what data is in the BRAM) and then go back to white after a few seconds. I am not able to communicate at all with the memory controller past this point. 

> [!C Code to Program FPGA from Flash]-
> ```C
> // program fpga
> ice_flash_init(FPGA_DATA.bus, ICE_FLASH_BAUDRATE);
> ice_flash_erase_chip(FPGA_DATA.bus);
> double bitstream_length = sizeof(bitstream) / sizeof(bitstream[0]);
> int num_pages = ceil(bitstream_length / ICE_FLASH_PAGE_SIZE);
> for(int i = 0; i < num_pages; i++) {
> 	// set up page data to write
> 	uint8_t page[ICE_FLASH_PAGE_SIZE];
> 	for(int j = 0; j < ICE_FLASH_PAGE_SIZE; j++) {
> 		int index = i * ICE_FLASH_PAGE_SIZE + j;
> 		if (index < bitstream_length) {
> 			page[j] = bitstream[index];
> 		}
> 	}
> 	  
> 	// write page to flash
> 	ice_flash_program_page(FPGA_DATA.bus, i * ICE_FLASH_PAGE_SIZE, page);
> }
> // start FPGA
> ice_led_init();
> ice_fpga_init(FPGA_DATA, 48);
> ice_fpga_start(FPGA_DATA);
> ```

It's possible that being able to reset the state machine would help solve that problem. However, I do think the random read process should guarantee the FPGA cycles states, which does not appear to be happening. Regardless, if I had more time I would use the button on the pico to send a reset signal to the FPGA.

If I had more time, I would work with doing a simpler warmboot (i.e. the images each light up a different number of LEDs) so that it would be easier to tell what's going on, but as it took me over an hour to get programming from the flash working, I decided just to move on.

I looked in the pico ice discord for anyone else who had attempted warmbooting, and it seems like it has been done last year, but they did not document their process.

### Simple Integration
Worked on integrating the memory controller with another design that also uses the memory. As Logan suggested, I used a simple adder that adds 5 to a set address in memory and stores in in another location. Once I had a working implementation, I met with Logan to make sure all my documentation on it was clear and he could understand what I was doing. We cleaned the design up a bit together.

The demo can be found on the [simple_integration](https://github.com/evolvablehardware/ice40_memory_controller/tree/simple_integration) branch of the memory controller repo. At the bottom of the readme, there's a brief description of how the integration works. Most important is the [adder module](https://github.com/evolvablehardware/ice40_memory_controller/blob/simple_integration/src_verilog/adder.v), which defines the memory controller signals needed to set bram block 0, address 2 to bram block 0, address 1 + 5. In the top level, there's lines that look like
```verilog
assign mem_signal = (active == 0) ? adder_mem_signal : controller_mem_signal;
```
These lines can be interpreted as: "Whenever the memory controller is actively doing an operation, use its memory control signals. Otherwise, use the memory control signals provided by the adder module."

[[2025-08-07|prev]] 
