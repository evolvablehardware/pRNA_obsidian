## Log
### Debugging Pico2
I worked on getting matching C code between my working [echo demo](https://github.com/evolvablehardware/BitstreamEvolutionPico/tree/rp2_ice_bram_controller/exampleProjectsC/rp2_ice_echo) and the memory controller. The main differences were that for the memory controller I was using a macro for the board type to set the pin variables correctly and was sending a reset signal to the board. After some debugging, I got some C code that works with the echo demo and should work with the memory controller. The only thing I changed was the macro from one I'm defining in the C file, to the PICO_PLATFORM set when cmake is called.

However, even after that change, the pico2 still seems to be stuck in the bootloader mode. The only real difference between the design is the up5k bistream, which should not affect how the firmware as their both just uint8 arrays at a high level. I messaged the devs:

>Just to clarify the above issue, it seems like even if I specified -DPICO_BOARD=pico2_ice, the PICO_PLATFORM would be rp2040. I'm not also specifying the platform, but I was confused since that did not seem like the intended behavior?
>
  After I've specified the correct platform, I'm now having issues where the device is just stuck in bootloader mode (I copy to uf2 file to  RP2350, the device disappears and then almost immediately pops back up as RP2350. Nothing is connected to the BT pin). I have a working echo demo, and I'm using the same C code and method of building for my main demo. The only difference is the up5k bitstream. What does the device being stuck in bootloader mode signify?

The devs suggested just deleting the build folder in between each build, which did work to get it flashed, as it seemed like switching platforms isn't fully supported. This does mean it takes a bit longer to build, but doesn't really change anything else.

I still had some issues with the pico2 where I need to send multiple dummy reads before it actually worked properly.
### Other work
Added in a feature to the shell that performs random reads and until it does once successfully, indicating it was able to get the device in the correct state
```
(R)ead, (W)rite, (T)riger warmboot, (S)ave current state to file, (I)nit SPRAM, Sync (D)evice: d
Performing random reads until device syncs
Attempt 1 at reading successfully
Attempt 2 at reading successfully
Attempt 3 at reading successfully
Attempt 4 at reading successfully
Attempt 5 at reading successfully
Attempt 6 at reading successfully
Attempt 7 at reading successfully
Performed successful read. Device is synced
```

I reran the testbench on the SPRAM of the pico2 with implicit BRAM, to confirm the results match what I received [[2025-08-01|last Friday]] on the pico1.

I figured out the explicit BRAM issue. There would a couple of issues in the makefile that caused the hex data files not to generate correctly. 

I updated the verilog documentation.

I ran the testbench on all of our different modes. It's a bit hard to read, but the main takeaways are that
- The UP5K is faster than the HX1K
- There's no significant difference between the pico and pico2
- There's no significant difference between implicit and explicit BRAM
- There's no significant difference between the BRAM and SPRAM
![[Pasted image 20250805173220.png]]

Found [documentation](https://www.raspberrypi.com/documentation/pico-sdk/hardware.html#group_hardware_uart) on the pico-sdk UART interface, so that I can time reads and writes. I found this [example](https://forums.raspberrypi.com/viewtopic.php?t=317018) of measuring how long it takes for code to execute. 
## Next
- Meet with Logan to discuss integrating the memory controller with the neural network
- Continue figuring out how to time read and writes from the pi
	- I'll start with just testing a single read/write
	- Then I'll need to figure out how to do multiple random read and writes
	- I'll also need to figure out how to get the recorded data back on the PC. I know there's 2 UART controllers on the pico, so hopefully I'll be able to use that 

[[2025-08-04|prev]] [[2025-08-06|next]]
